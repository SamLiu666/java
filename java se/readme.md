# java 记录

| 进度   |           |
| ------ | --------- |
| 常用类 | 2020/4/18 |
| 泛型   |           |
|        |           |

# 基础语法

在 Java 这门语言体系当中，最基础的部分就是 Java SE 部分，Java 的标准版本。它包括 Java 最基础的一些结构，包括面向对象的一些特性等等，同时它也是 Java 技术基础和核心。在 Java SE 的基础之上，又分为了 Java EE（Java 的企业版），应用于大型企业级应用的开发。Java ME 主要用于嵌入式开发。



JVM 叫 Java 虚拟机，它也是整个 Java 技术的核心。Java 语言的跨平台就多亏了 JVM。

JDK 叫 Java 开发工具包，没有 JDK 就没有办法进行 Java 程序的开发。

JRE 叫 Java 运行环境，如果我们需要运行一个 Java 程序，就得安装 JRE。

JDK、JRE 和 JVM 之间的关系：

编译源代码：打开命令行，切换到源代码目录，这里是 `/home/project`。输入 `javac HelloWorld.java`，如果程序没有任何提示，并且在同级目录下生成了一个 `.class` 扩展名的文件，那么说明编译成功，反之编译失败

## 数据类型

#### 整数

`byte`、`short`、`int`、`long` 四种基本数据类型表示整数，需要注意的是 `long` 类型，使用 `long` 修饰的变量需要在数值后面加上 L 或者 l，比如 `long num = 1L;`，一般使用大写 `L`，为了避免小写 `l` 与数值 `1` 混淆。

#### 浮点数

`float` 和 `double` 类型表示浮点数，即可以表示小数部分。需要注意的是 `float` 类型的数值后面需要加上 `F` 或者 `f`，否则会被当成 `double` 类型处理。`double` 类型的数值可以加上 `D` 或 `d`，也可以不加。

#### char 类型

char 类型用于表示单个字符。需要将字符用单引号括起来`char a = 'a'`，char 可以和整数互相转换，如果字符 `a` 也可以写成`char a = 97`。也可以用十六进制表示`char a = '\u0061'`。

#### boolean 类型

`boolean` 类型（布尔类型）用于表示真值 `true`或者假值 `false`，Java 中布尔值不能和整数类型或者其它类型互相转换。



前缀自增自减法 (++i,--i): 先进行自增或者自减运算，再进行表达式运算。后缀自增自减法 (i++,i--): 先进行表达式运算，再进行自增或者自减运算

## 类

1. 局部变量的作用域仅限于定义它的方法内。而成员变量的作用域在整个类内部都是可见的。
2. 同时在相同的方法中，不能有同名的局部变量；在不同的方法中，可以有同名的局部变量。
3. 成员变量和局部变量同名时，局部变量具有更高的优先级。 大家可以编写代码验证一下

**构造方法**。每个类都有构造方法，在创建该类的对象的时候他们将被调用，如果没有定义构造方法，Java 编译器会提供一个默认构造方法。 创建一个对象的时候，至少调用一个构造方法。比如在新建一个对象 `new Object()`，括号中没有任何参数，代表调用一个无参构造方法（默认构造方法就是一个无参构造方法）。构造方法的名称必须与类名相同，一个类可以定义多个构造方法。



Java 中被 `static` 修饰的成员称为**静态成员或类成员**。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。



`final` 关键字可以修饰类、方法、属性和变量

1. `final` 修饰类，则该类不允许被继承，为最终类
2. `final` 修饰方法，则该方法不允许被覆盖（重写）
3. `final` 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）
4. final 修饰变量，则该变量的值只能赋一次值，即常量

## 封装

如何去实现类的封装呢？

1. 修改属性的可见性，在属性的前面添加修饰符 (`private`)
2. 对每个值属性提供对外的公共方法访问，如创建 getter/setter（取值和赋值）方法，用于对私有属性的访问
3. 在 getter/setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定。

`this` 关键字代表当前对象。使用 `this.属性` 操作当前对象的属性，`this.方法` 调用当前对象的方法。

用 `private` 修饰的属性，必须定义 getter 和 setter 方法才可以访问到 (Eclipse 和 IDEA 等 IDE 都有自动生成 getter 和 setter 方法的功能）

## 继承

#### 方法重载

方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法。

## 多态

#### 多态的实现条件

**Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。**

只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。

#### 多态的实现方式

Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现

**因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写（方法名，参数都相同）**



## 抽象类

## 接口

在 Java8 中：

- 接口不能用于实例化对象。
- 接口中方法只能是抽象方法、`default` 方法、静态方法。
- 接口成员是 `static final` 类型。
- 接口支持多继承。

在 Java9 中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 `default` 方法和静态方法使用。

## 内部类

将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类。

内部类的主要作用如下：

1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便
4. 内部类允许继承多个非接口类型（具体将在以后的内容进行讲解）

> 注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 `outer.class` 和 `outer$inner.class` 两类。所以内部类的成员变量 / 方法名可以和外部类的相同。

**静态内部类通常被称为嵌套类。**

静态内部类是 `static` 修饰的内部类，这种内部类的特点是：

1. 静态内部类不能直接访问外部类的非静态成员，但可以通过 `new 外部类().成员` 的方式访问。
2. 如果外部类的静态成员与内部类的成员名称相同，可通过 `类名.静态成员` 访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过 `成员名` 直接调用外部类的静态成员。
3. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 `内部类 对象名 = new 内部类();`。



## 匿名内部类

匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。

## Package 

**包的作用**

- 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
- 包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。
- 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

## 数组

| 方法                                     | 描述                             |
| ---------------------------------------- | -------------------------------- |
| <T> List<T> asList(T... a)               | 返回由指定数组构造的 List        |
| void sort(Object[] a)                    | 对数组进行排序                   |
| void fill(Object[] a, Object val)        | 为数组的所有元素都赋上相同的值   |
| boolean equals(Object[] a, Object[] a2)  | 检查两个数组是否相等             |
| int binarySearch(Object[] a, Object key) | 对排序后的数组使用二分法查找数据 |

## StringBuilder 类

StringBuilder 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的）。

| 方法                                    | 返回值        | 功能描述                                                     |
| --------------------------------------- | ------------- | ------------------------------------------------------------ |
| insert(int offsetm,Object obj)          | StringBuilder | 在 offsetm 的位置插入字符串 obj                              |
| append(Object obj)                      | StringBuilder | 在字符串末尾追加字符串 obj                                   |
| length()                                | int           | 确定 StringBuilder 对象的长度                                |
| setCharAt(int index,char ch)            | void          | 使用 ch 指定的新值设置 index 指定的位置上的字符              |
| toString()                              | String        | 转换为字符串形式                                             |
| reverse()                               | StringBuilder | 反转字符串                                                   |
| delete(int start, int end)              | StringBuilder | 删除调用对象中从 start 位置开始直到 end 指定的索引（end-1）位置的字符序列 |
| replace(int start, int end, String str) | StringBuilder | 使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束 |

## Calendar 类

| 构造方法                                        | 说明                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| GregorianCalendar()                             | 创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处的时区、地点的当前时间 |
| GregorianCalendar(TimeZone zone)                | 创建的对象中的相关值被设置成指定时区 zone，缺省地点的当前时间 |
| GregorianCalendar(Locale aLocale)               | 创建的对象中的相关值被设置成缺省时区，指定地点 aLocale 的当前时间 |
| GregorianCalendar(TimeZone zone,Locale aLocale) | year - 创建的对象中的相关值被设置成指定时区，指定地点的当前时间 |

## 泛型

泛型即参数化类型，也就是说数据类型变成了一个可变的参数，在不使用泛型的情况下，参数的数据类型都是写死了的，使用泛型之后，可以根据程序的需要进行改变。

定义泛型的规则：

- 只能是引用类型，不能是简单数据类型。
- 泛型参数可以有多个。
- 可以用使用 `extends` 语句或者 `super` 语句 如 `` 表示类型的上界，`T` 只能是 `superClass` 或其子类， `` 表示类型的下界，`K` 只能是 `childClass` 或其父类。
- 可以是通配符类型，比如常见的 `Class`。单独使用 `?` 可以表示任意类型。也可以结合 `extends` 和 `super` 来进行限制。

## 集合

集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。

![集合](https://doc.shiyanlou.com/document-uid79144labid1102timestamp1435844913664.png/wm)

因为集合框架中的很多类功能是相似的，所以我们用接口来规范类。Collection 接口是 Java 集合框架里的一个根接口。它也是 List、Set 和 Queue 接口的父接口。Collection 接口中定义了可用于操作 List、Set 和 Queue 的方法——增删改查。

| 方法                             | 返回值   | 说明                                                         |
| -------------------------------- | -------- | ------------------------------------------------------------ |
| add(E e)                         | boolean  | 向 collection 的尾部追加指定的元素（可选操作）               |
| addAll(Collection<? extend E> c) | boolean  | 将指定 collection 中的所有元素都添加到此 collection 中（可选操作） |
| clear()                          | void     | 移除此 collection 中的所有元素（可选操作）                   |
| contains(Object o)               | boolean  | 如果此 collection 包含指定的元素，则返回 true                |
| containsAll(Collection<?> c)     | boolean  | 如果此 collection 包含指定 collection 的所有元素，则返回 true |
| equals(Object o)                 | boolean  | 比较此 collection 与指定对象是否相等                         |
| hashCode()                       | int      | 返回此 collection 的哈希码值                                 |
| isEmpty()                        | boolean  | 如果此 collection 不包含元素，则返回 true                    |
| iterator()                       | Iterator | 返回在此 collection 的元素上进行迭代的迭代器                 |
| remove(Object o)                 | boolean  | 移除此 collection 中出现的首个指定元素（可选操作）           |
| removeAll(Collection<?> c)       | boolean  | 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作） |
| retainAll(Collection<?> c)       | boolean  | 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作） |
| size()                           | int      | 返回此 collection 中的元素数                                 |
| toArray()                        | Object[] | 返回包含此 collection 中所有元素的数组                       |
| toArray(T[] a)                   | T[]      | 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同 |

### list

`List` 是一个接口，**不能实例化**，需要一个具体类来实现实例化。

List 集合中的对象按照一定的顺序排放，里面的内容可以重复。 `List` 接口实现的类有：`ArrayList`（实现动态数组），`Vector`（实现动态数组），`LinkedList`（实现链表），`Stack`（实现堆栈）。

## map set hash-set

# 异常

异常通常有四类：

- Error：系统内部错误，这类错误由系统进行处理，程序本身无需捕获处理。
- Exception：可以处理的异常。
- RuntimeException：可以捕获，也可以不捕获的异常。
- 继承 Exception 的其他类：必须捕获，通常在 API 文档中会说明这些方法抛出哪些异常。

throws 用于声明异常，表示该方法可能会抛出的异常。如果声明的异常中包括 checked 异常（受检异常），那么调用者必须捕获处理该异常或者使用 `throws` 继续向上抛出。`throws` 位于方法体前，多个异常之间使用 `,` 分割。

## 函数式编程

parameter -> expression body

MathOperation subtraction = (a, b) -> a - b;

## 方法引用

```java
        List<String> names = new ArrayList<>();

        names.add("Peter");
        names.add("Linda");
        names.add("Smith");
        names.add("Zack");
        names.add("Bob");

        //    通过System.out::println引用了输出的方法names.forEach(System.out::println);
        names.forEach(System.out::println);
```



## Stream 流

Stream 代表了来自某个源的对象的序列，这些序列支持聚集操作。下面是 Stream 的一些特性：

- 元素序列：Stream 以序列的形式提供了特定类型的元素的集合。根据需求，它可以获得和计算元素，但不会储存任何元素。
- 源：Stream 可以将集合、数组和 I/O 资源作为输入源。
- 聚集操作：Stream 支持诸如 `filter`、`map`、`limit`、`reduce` 等的聚集操作。
- 流水技术：许多 Stream 操作返回了流本身，故它们的返回值可以以流水的行式存在。这些操作称之为中间操作，并且它们的功能就是负责输入、处理和向目标输出。`collect()` 方法是一个终结操作，通常存在于流水线操作的末端，来标记流的结束。
- 自动迭代：Stream 的操作可以基于已提供的源元素进行内部的迭代，而集合则需要显式的迭代。

## 文件



